#!/usr/bin/env ruby
require "ruby_grammar_builder"

# Unicode characters can be used in identifiers, except for U+3000 (full-width space).
RX_ident = /\b[a-zA-Z_\u0080-\u2fff\u3001-\uffff][a-zA-Z_0-9\u0080-\u2fff\u3001-\uffff]*\b/

grammar = Grammar.new(
    name: "System4",
    scope_name: "source.system4",
    fileTypes: ["jaf"],
    version: "",
    information_for_contributors: [
        "This json file was auto generated by grammar.rb.",
        "Do not edit it directly.",
    ],
)

grammar[:comments] = [
    PatternRange.new(
        tag_as: "comment.block.system4",
        start_pattern: Pattern.new(
            match: %r|/\*|,
            tag_as: 'punctuation.definition.comment.begin.system4'
        ),
        end_pattern: Pattern.new(
            match: %r|\*/|,
            tag_as: 'punctuation.definition.comment.end.system4'
        ),
    ),
    Pattern.new(
        tag_as: "comment.line.system4",
        match: %r|//.*$|,
    )
]

grammar[:keywords] = [
    Pattern.new(
        match: /\b(?:break|continue|return|goto|jumps?|if|else|for|while|do|switch|case|default)\b/,
        tag_as: "keyword.control.system4",
    ),
    Pattern.new(
        match: /\b(?:const|ref|array@)\b/,
        tag_as: "storage.modifier.system4",
    ),
    Pattern.new(
        match: /\b(?:public|private)\b/,
        tag_as: "storage.type.modifier.$0.system4",
    ),
    Pattern.new(
        match: /\b(?:void|char|int|float|string|bool|lint)\b/,
        tag_as: "storage.type.system4",
    ),
    Pattern.new(
        match: /\b(?:class|struct)\b/,
        tag_as: "storage.type.system4",
    ).then(@spaces).then(
        match: RX_ident,
        tag_as: "entity.name.type.$1.system4",
    ),
    Pattern.new(
        match: /\b(?:functype|delegate)\b/,
        tag_as: "keyword.other.$0.system4",
    ),
    Pattern.new(
        match: /\b(?:this|system)\b/,
        tag_as: "variable.language.$0.system4",
    ),
    Pattern.new(
        match: /\b(?:ifn?def|endif)\b/,
        tag_as: "keyword.control.directive.conditional.$0.system4",
    ),
    Pattern.new(
        match: /\bassert\b/,
        tag_as: "keyword.operator.$0.system4",
    ),
]

grammar[:operators] = [
    Pattern.new(
        match: /<=?|>=?|[!=]==?/,
        tag_as: "keyword.operator.comparison.system4",
    ),
    Pattern.new(
        match: %r!(?:[-+*/%&^|]|<<|>>)=|<-|<=>!,
        tag_as: "keyword.operator.assignment.system4",
    ),
    Pattern.new(
        match: /!|&&|\|\|/,
        tag_as: "keyword.operator.logical.system4",
    ),
    Pattern.new(
        match: /[&^|~]|<<|>>/,
        tag_as: "keyword.operator.bitwise.system4",
    ),
    Pattern.new(
        match: %r!\+\+|--|[-+*/%]!,
        tag_as: "keyword.operator.arithmetic.system4",
    ),
    Pattern.new(
        match: /=/,
        tag_as: "keyword.operator.assignment.system4",
    ),
    Pattern.new(
        match: /\bnew\b/,
        tag_as: "keyword.other.system4"
    ),
    Pattern.new(
        match: /\b__(?:FILE|LINE|FUNC|DATE|TIME)__\b/,
        tag_as: "entity.name.other.preprocessor.macro.predefined.$0.system4"
    ),
]

grammar[:punctuations] = [
    Pattern.new(
        match: /;/,
        tag_as: "punctuation.terminator.system4",
    ),
    Pattern.new(
        match: /,/,
        tag_as: "punctuation.separator.system4",
    ),
    Pattern.new(
        match: /\(/,
        tag_as: "punctuation.section.arguments.begin.system4",
    ),
    Pattern.new(
        match: /\)/,
        tag_as: "punctuation.section.arguments.end.system4",
    ),
    Pattern.new(
        match: /\[/,
        tag_as: "punctuation.section.subscript.begin.system4",
    ),
    Pattern.new(
        match: /\]/,
        tag_as: "punctuation.section.subscript.end.system4",
    ),
    Pattern.new(
        match: /\{/,
        tag_as: "punctuation.section.block.begin.system4",
    ),
    Pattern.new(
        match: /\}/,
        tag_as: "punctuation.section.block.end.system4",
    ),
    Pattern.new(
        match: /\./,
        tag_as: "punctuation.accessor.member.system4",
    ),
]

grammar[:literals] = [
    Pattern.new(
        match: /\b(?:NULL|true|false)\b/,
        tag_as: "constant.language.system4"
    ),
    Pattern.new(
        match: /0[bB][01]+/,
        tag_as: "constant.numeric.binary.system4"
    ),
    Pattern.new(
        match: /0[oO][0-7]+/,
        tag_as: "constant.numeric.octal.system4"
    ),
    Pattern.new(
        match: /0[xX][0-9a-fA-F]+/,
        tag_as: "constant.numeric.hex.system4"
    ),
    Pattern.new(
        match: /[0-9]+(?:\.[0-9]+)?(?:[eE][+-]?[0-9]+)?/,
        tag_as: "constant.numeric.decimal.system4"
    ),
    :string,
    :message,
]

grammar[:string] = PatternRange.new(
    tag_as: "string.quoted.double.system4",
    start_pattern: Pattern.new(
        match: /"/,
        tag_as: 'punctuation.definition.string.begin.system4'
    ),
    end_pattern: Pattern.new(
        match: /"/,
        tag_as: 'punctuation.definition.string.end.system4'
    ),
    includes: [
        :escape_pattern,
    ],
)
grammar[:message] = PatternRange.new(
    tag_as: "text.system4",  # to make it distinguishable from string
    start_pattern: Pattern.new(
        match: /'/,
        tag_as: 'punctuation.definition.message.begin.system4'
    ),
    end_pattern: Pattern.new(
        match: /'/,
        tag_as: 'punctuation.definition.message.end.system4'
    ),
    includes: [
        :escape_pattern,
    ],
)
grammar[:escape_pattern] = Pattern.new(
    match: /\\./,
    tag_as: "constant.character.escape.system4",
)

grammar[:$initial_context] = [
    :comments,
    :keywords,
    :operators,
    :punctuations,
    :literals,

    # ident '::' '~'? ident
    Pattern.new(
        match: RX_ident,
        tag_as: "entity.name.type.system4"
    ).then(
        match: /::/,
        tag_as: "punctuation.separator.namespace.system4"
    ).maybe(/~/).then(
        match: RX_ident,
        tag_as: "entity.name.function.system4"
    ),

    # ident
    Pattern.new(
        match: RX_ident,
        tag_as: "variable.other.system4"
    ),
]

grammar.save_to(
    syntax_name: "system4",
    generate_tags: false,
)
